# JVM学习笔记

#####1. Java内存区域与内存溢出异常

###### 1.1 运行时数据区划分

- **程序计数器**
  - 程序计数器是一块较小的内存空间，他可以看作是当前线程所执行的字节码的行号指示器。
    - 如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址。
    - 如果正在执行的是Native方法，这个计数器则为空
  - 线程私有。
  - 是唯一一个在java虚拟机规范中没有规定任何OOM情况的区域。

- **Java虚拟机栈**
  - 线程私有，生命周期与线程相同。
  - 虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个==栈帧==用于存储==局部变量表、操作数栈、动态链接、方法出口==等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
    - 局部变量表：存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，他不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。
  - 两种异常：
    - 如果线程请求的栈的深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。
    - 如果虚拟机栈可以动态扩展，若果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常
- **本地方法栈**
  - 本地方法栈与虚拟机栈所发挥的作用非常相似，之间的区别不过只虚拟机栈为虚拟机执行java方法服务。而本地方法栈为执行Native方法服务。
  - 两种异常：
    - 如果线程请求的栈的深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。
    - 如果虚拟机栈可以动态扩展，若果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常
- 堆：
  - java虚拟机所管理的内存中最大的一块。
  - 被所有线程共享的一块内存区域。
  - 存放实例对象。
  - 是垃圾收集器管理的主要区域。
    - 从内存回收角度来看：现在收集器基本都采用**分代收集算法**，所以java堆还可以细分为：==新生代==和==老年代==；在细致一点有Eden空间、From Survivor空间、To Survivor空间等。
    - 从内存分配角度来看：线程共享的java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。
  - 异常：如果堆中没有内存完成实例分配，并且堆也无法在扩展时，将会抛出OutOfMemoryError异常。
- **方法区**：
  - 线程共享的内存区域。
  - 用于存储已被虚拟机加载的类信息。常量、静态变量、及时编译器编译后的代码等数据。
  - 异常：当方法区无法满足内存分配需求时，将会抛出OutOfMemoryError异常。
- **运行时常量池**：
  - 是方法区的一部分。
  - Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池，用于存放编译期生成的各种字面量和符号引用。这部分内容将在类加载后进入方法区的运行常量池。
  - 异常：当常量池无法再申请到内存时会抛出OutOfMemoryError异常。

###### 1.2 HotSpot虚拟机对象探秘（对象分配、布局和访问）

- 对象的创建

  - 四种创建方法：

    - 调用new语句创建对象，最常见的一种。

    - clone方法创建对象。

      ```java
      clone时，需要已经有一个分配了内存的源对象，创建新对象时，首先应该分配一个和源对象一样大的内存空间。要调用clone方法需要实现Cloneable接口，由于clone方法是protected的，所以修改Hello类。
      ```

    - 反射方法newInstance创建对象

      ```java
      	Class heroClass = Class.forName("yunche.test.Hello");
          Hello h =(Hello) heroClass.newInstance();
      ```

    - 序列化readObject()方法创建对象

      ```java
      		Hello h = new Hello();
                //准备一个文件用于存储该对象的信息
                File f = new File("hello.obj");
                try{
                    FileOutputStream fos = new FileOutputStream(f);
                    ObjectOutputStream oos = new ObjectOutputStream(fos);
                    FileInputStream fis = new FileInputStream(f);
                    ObjectInputStream ois = new ObjectInputStream(fis)
                    //序列化对象，写入到磁盘中
                    oos.writeObject(h);
                    //反序列化对象
                    Hello newHello = (Hello)ois.readObject();
                    //测试方法
                    newHello.sayWorld();
                }catch (FileNotFoundException e){
                    e.printStackTrace();
                }catch (IOException e){
                    e.printStackTrace();
                }catch (ClassNotFoundException e){
                    e.printStackTrace();
                }
      //使用序列化时，要实现实现Serializable接口，将一个对象序列化到磁盘上，而采用反序列化可以将磁盘上的对象信息转化到内存中.
      ```

  - ==对象的创建过程==

    - 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过，如果没有，那必须先进行相应的类加载过程。在类加载检查通过后，虚拟机将为新生对象分配内存（两种分配方式：**指针碰撞**和**空闲列表**）。内存分配完成后虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），接下来，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例，如何才能找到类的元数据信息、对象的哈希吗、对象的GC分代年龄等信息，这些信息存放在对象的对象头中。完成上面工作之后，从虚拟机角度来看，一个新的对象已经产生了，但是从java程序的角度来看，对象创建才刚开始---<init>方法还没执行，所有字段还为0,。所以执行new指令之后会接着执行<init>方法，把对象进行初始化，这样一个真正可用的对象才算完全产生出来。

- **对象的内存布局**：

  -  对象在内存中存储的布局可以分为3块区域：对象头、实例数据、对齐填充。

  - **对象头**：

    - **第一部分**：用于存储对象自身运行时数据，如哈希吗（hashCode）、GC分代年龄、锁状态标识、线程持有的锁、偏向线程的ID、偏向时间戳等、这部分数据长度在32位和64位的虚拟机中分别为32bit和64bit。

    - 表HotSpot虚拟机对象头Mark Word

      |               存储内容               | 标志位 |       状态       |
      | :----------------------------------: | :----: | :--------------: |
      |       对象哈希吗、对象分代年龄       |   01   |      未锁定      |
      |           指向锁记录的指针           |   00   |    轻量级锁定    |
      |          指向重量级锁的指针          |   10   | 膨胀（重量级锁定 |
      |          空，不需要记录信息          |   11   |      GC标记      |
      | 偏向线程ID、偏向时间戳、对象分代年龄 |   01   |      可偏向      |

    - **另一部分**：类型指针即对象指向它的元数据的指针。

    - 注：如果对象是一个java数组。那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通java对象的元数据信息确定java对象的大小，但是从数组的元数据中却无法确定数组大小。

  - **实例数据**：

    - 对象真正存储的有效信息，也是程序代码中所定义的各种类型的字段内容。

  - 对其填充：

    - 占位符：HotSpot  VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍。

- **对象的访问定位**：

  - 目前主流的访问方式有==使用句柄==和==直接指针==两种。

  - 使用句柄访问：

    - Java堆中将会划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。

      ![](D:\SpringPhoto\通过句柄访问对象.png)

  - 使用直接指针访问：

    - java堆对象布局中放置访问类型数据相关信息，reference中存储的直接就是对象地址。

      ![](D:\SpringPhoto\直接指针访问对象.png)

  - 两种方式各有优势：
    - 使用句柄优势：reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时，只会改变句柄中实例数据指针。
    - 使用直接指针优势：速度快，节省了一次指针定位的时间开销。

##### 2. 垃圾收集器与内存分配策略

###### 2.1 问题？

- 1.那些内存需要回收？
- 2.什么时候回收？
- 3.如何回收？
- 4.为什么了解GC和内存分配？
  - 答：当需要排查各种内存溢出、内存泄漏问题时当垃圾收集成为系统高并发量的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。

###### 2.2 判断对象是否存活

- 判断对象是否存活的方法主要有：引用计数算法和==可达性分析算法==。
- 引用计数算法：
  - 给对象添加一个引用计数器，每当一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能在被对象使用的。
  - 缺点：很难解决对象之间相互循环引用的问题。

- **可达性分析算法**：
  - 通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。
    - **可作为GC Roots的对象**
      - 虚拟机栈（栈帧中本地变量表）中引用的对象。
      - 方法区中类静态属性引用的对象。
      - 方法区中常量引用的对象。
      - 本地方法栈中JNI（即一般说的Native方法）引用的对象。
  - 引用分类：
    - 强引用：普遍存在类似Object  obj  = new  Object ();
    - 软引用：描述一些还有用但并非必须的对象。
    - 弱引用：只能生存到下一次垃圾回收之前。
    - 虚引用：最弱的一种引用。

- **生存还是死亡**
  - 判断一个对象是否死亡，至少要经历两次标记过程：如果对象在进行可达性分析算法后发现没有与GC Roots相连的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是次对象是否有必要执行finalize()方法（当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况多是为i“没必要执行”）。如果这个对象被判定为有必要执行，那么这个对象将会被放在一个F-Queue队列中，然后有虚拟机创建一个低优先级的Finalizer线程去执行他。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后虚拟机将会对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize()中成功拯救自己-----只要重新与引用链的任何一个对象建立关联即可。如果自救成功，那他在第二次标记时就会被移除“即将回收”的集合。如果对象没有自救成功，那基本上就真的被回收了。

###### 2.3 垃圾收集算法

- ==标记-清除算法==
  - 算法分为两个阶段：标记和清除。首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象（可达性分析算法标记）。
  - 缺点：效率问题，标记和清除两个过程效率都不高。空间问题，标记清除后会产生大量不连续的内存碎片。
- ==复制算法==
  - 将可用内存划分为大小相等的两块，每次只用其中的一块，当一块内存用完了，就将还存活着的对象复制到另一块上面，然后把已使用过的内存空间一次清理掉。
  - 优点：效率高，每次都对整个半区进行内存回收，不用考虑内存碎片问题。
  - 缺点：代价是原来内存缩小为原来的一半，代价太高。
- ==标记-整理算法==
  - **标记-整理**算法标记过程与**标记-清除**算法一样，但后续步骤不是直接对回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界意外的内存。
- ==分代收集算法==

  - 根据对象存活周期的不同将内存划分为几块。一般把java堆分为**新生代**和**老年代**：在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法。而老年代中对象存活率高、没有额外空间对它进行分配担保，就必须使用**标记-清理**或者**标记-整理**算法进行回收。

###### 2.4 垃圾收集器

- Serial收集器

  - 发展历史最悠久的收集器。
  - 用于新生代（复制算法）

  - 是一个单线程收集器。垃圾收集时，必须暂停（STW）其他所有的工作线程，直到它收集结束。
  - 在Client模式下的默认新生代收集器。
  - 优于其他收集器的地方：简单而高效（与其他收集器的单线程相比）

- ParNew收集器

  - ParNew收集器其实就是Serial收集器的多线程版本。
  - 用于新生代（复制算法）
  - 行为都与Serial收集器一样。如控制参数、收集算法、STW、对象分配规则、回收策略等。
  - 许多运行在Server模式下的虚拟机首选的新生代收集器。（原因：除了Serial收集器外，目前只有它能与CMS收集器配合工作）
  - ParNew收集器在单CPU环境下绝不会比Serial收集器更好(存在线程交互开销)，但是随着CPU数量的增加，它对于GC时系统资源的有效利用还是很有好处的。

- Parallel Scavenge(并行收集器)

  - 是新生代收集器。
  - 使用复制算法。
  - 并行的多线程收集器。
  - Parallel Scavenge收集器的目标是达到一个可控的吞吐量。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，及吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)。虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。
  - Parallel Scavenge收集器提供两个参数用于精确控制吞吐量。控制最大垃圾收集停顿时间-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio.
  - 自适应调节策略：-XX:+UseAdaptiveSizePolicy

- Serial Old收集器

  - 是Serial收集器的老年代版本。
  - 单线程收集器。
  - 使用**标记-整理**算法
  - 在Client模式下的虚拟机使用。如果在Server模式下，那么它主要还有两大用途：一种是在jdk1.5以前的版本中与Parallel Scavenge收集器搭配使用。另一种就是作为CMS收集器的后备预案，在并发收集发生Concurrent  Mode Failure时使用。

- Parallel Old 收集器
  - 是Parallel Scavenge收集器的老年代版本。
  - 配合Parallel Scavenge收集器使用。
- ==CMS==收集器
  - 是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿之间最短，以给用户带来加好的体验。
  - 基于==标记-清除==算法
  - 运作过程：
    - 初始标记：
    - 并发标记
    - 重新标记
    - 并发清除
    - 其中，初始标记和重新标记需要Stop the World。初始标记只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记时间短。
    - 并发标记和并发清除过程收集器线程是与用户线程一起工作，所以，从总体上来说CMS收集器的内存回收过程是与用户线程一起并发执行的。
  - 3个缺点：
    - CMS收集器对CPU资源非常敏感。
    - CMS收集器无法处理浮动垃圾
    - 由于使用**标记-清除**算法会有大量空间碎片产生。
- ==G1收集器==
  * G1是一款面向服务端应用的垃圾收集器。HotSpot 开发团队赋予它的使命是未来可以替换掉CMS收集器。
  * 特点：
    * **并行与并发**：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短**Stop the World**的停顿时间，部分其他收集器原本需要停顿java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。
    * **分代收集**：能够采用不同的方式去处理新创建的对象和已经存活一段时间、熬过多次GC的旧对象以获取更好的收集效果。
    * **空间整合**：从整体上来看是基于**标记-整理**算法实现的垃圾收集。从局部来看是基于**复制**算法实现的。这两种算法都不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象是不会因为无法找到连续内存空间而提前出发下一次GC。
    * **可预测的停顿**：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java的垃圾收集器特征了。
  * ==G1收集器将整个java堆划分为多个大小相等的独立区域（Region）==还保留着新生代和老年代的概念，但是新生代与老年代不在是物理隔离的了，他们都是一部分Region（不需要连续）的集合。